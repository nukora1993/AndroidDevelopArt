#Activity的启动：
#startActivity函数有好几种重载，但是最终都会调用startActivityForResult

#startActivityForResult:
#首先检查mParent是否为null，如果为null则调用execStartActivity，一般都是这个流程
#mParent是一个ActivityGroup，Activity本来有ActivityGroup的概念，用来在一个界面放入多个activity，但是从API13被移除，推荐使用Fragment
#getApplicationThread获得ApplicationThread，ApplicationThread是ActivityThread的内部类


#注意Android Q之前都是通过AMS启动的，但是Android Q之后是通过ActivityTaskManager启动的，所以下面的描述可能不一定对
#启动Activity的真正实现是ActivityTaskManager.getService()的startActivity方法
#ActivityTaskManager.getService返回的是IActivityTaskManager，是一个单例
#具体来说，调用了ServiceManager.getService(Context.ACTIVITY_TASK_SERVICE)得到了binder，然后asInterface得到了IActivityTaskManager
#因而实际的启动Activity过程由ActivityTaskManager（binder）完成，然后调用checkStartActivityResult检查启动的结果

#而ActivityTaskManager的startActivity又调用了ActivityStackSupervisor#startActivityMayWait
#然后又调用了startActivityLocked,里面又调用了startActivitUncheckedLocked,接着调用了ActivityStack的resumeRopActivitiesLocked
#这时候，启动过程转移到了ActivityStack
#然后又调用了resumeTopActivityInnerLocked,接着调用ActivityStackSupervisor的startSpecificActivityLocked
#然后又调realStartActivityLocked
#可以看到，启动过程是ActivityStackSupervisor->ActivityStack->ActivityStackSupervisor,由两个类实现
#在realStartActivityLocked中会使用app.thread进行启动，而app.thread的实际类型是IApplicationThread,也是一个binder
#IApplicationThread包含了启动、停止Activity和Service的方法，其具体实现类是其内部类ApplicationThread
#所以，最终Activity的启动是由ApplicationThread完成，通过其scheduleLaunchActivity
#而该方法也很简单，就是发送一个LAUNCH_ACTIVITY消息给Handler处理，当handler收到该消息时，会调用handleLaunchActivity方法
#然后调用了performLaunchActivity，该方法主要有如下过程：
#从ActivityClientRecord获取待启动的Activity组件信息
#通过Instrumentation的newActivity使用类加载器创建Activity对象
#通过LoadedApk的makeApplication来尝试创建Application对象，之所以说时尝试，是因为如果Application已经创建那么就不会再创建
#Application对象的创建也是Instrumentation通过类加载器实现
#创建ContextImpl并通过Activity的attach方法完成一些重要数据的初始化，ContextImpl时Context的具体实现，通过attach方法和Activity建立关联
#attach方法还会创建window并建立关联
#最终调用onCreate方法
#所以说Activity本身不是context，但是继承了contextwrap，而contextwrap的接口和context一样，并且调用的都是和Activity关联的context方法，使得Activity看上去就像是Context


#Service的启动过程：
#调用startService->调用mBase的startService，mBase就是之前和attach的ContextImpl
#然后调用startServiceCommon,然后通过ActivityTaskManager发起IPC，调用startService
#具体实现时通过操作mServices,这是一个ActiveServices对象，作用时辅助ActivityTaskManager进行Service管理
#调用ActiveServices#startServiceLocked,然后调用startServiceInnerLocked
#然后使用ServiceRecored交给bringUpServiceLocked处理，然后调用realStartServiceLocked
#然后调用app.thread的scheduleCreateService来创建Service对象，然后调用onCreate
#接着调用sendServiceArgsLocked调用Service的其他方法
#scheduleCreateService和sendServiceArgsLocked都是IPC调用（因为app.thread时binder）
#和Activity类似，scheduleCreateService也是通过发送异步消息给Handler，最终通过handleCreateService完成Service启动
#handleCreateService主要完成：
#通过类加载器创建Service实例，创建Application对象，创建ContextImpl并且attach，最后调用service的onCreate并且添加到一个列表，然后调用handleServiceArgs

#AMS运行再系统进程，app通过ActivityThread调用AMS接口，AMS又通过ApplicationThread调用app接口，完成实际的创建
#也就说AMS只是完成组件的管理，但是具体创建还是由app自己完成

#Service绑定过程：
#调用其ContextImpl的bindService，然后调用bindServiceCommon，主要过程
#将客户端的ServiceConnection转换为ServiceDispatcher.InnerConnection,因为bind可能时跨进程的，如果时跨进程，那么connection必须借助与binder才能让服务端回调自己的方法
#这也是为什么再跨进程bindService时不用为connection创建binder，因为service已经转换过了
#serviceDispatcher的作用时连接ServiceConnection和InnerConnection，具体是由LoadedApk的getServiceDispatcher方法完成
#该方法中mServices是一个ArrayMap，存储了当前Activity和ServiceDispatcher之间的樱色和关系
#系统会查找是否存在相同的ServiceConnection，如果不存在则创建新的ServiceDispatcher对象并存储再mServices
#key就是ServiceConnection，value就是ServiceDispatcher
#ServiceDispatcher又保存了ServiceConnection和InnerConnection
#Service和Activity建立连接后，系统通过IPC，InnerConnection调用ServiceConnection的onServiceConnected

#bindServiceCommon会通过AMS完成具体绑定，具体是AMS的bindService方法
#调用ActiveServices的bindServiceLocked。调用bringUpServiceLocked，调用readlStartServiceLocked
#最终通过ApplicationThread完成Service实例，不同于启动Service，绑定过程会调用scheduleBindService
#实现实在ActiveService的requestServiceBindingLocked
#然后Handler处理BIND_SERVICE消息，调用Service的onBind，然后回调ServiceConnection的onServiceConnected
#该过程由AMS的publishService方法完成，具体又ActiveService的mService处理，最终是调用InnerConnection中的connected方法
#然后调用了ServiceDispatcher的connected方法，然后就是发了一个消息给handler

#注意到bindService的发起者是客户端，所以InnerServiceConnection是客户端提供的，Service可以拿到并进行IPC调用

#BroadcastReceiver过程：
#静态注册是由PMS（PackageManageService）完成的，除了静态注册的receiver，其他三大组件也是PMS完成解析并注册
#动态注册：registerReceiver：调用了ContextImpl的registerReceiver
#调用了registerReceiverInternal
#该方法首先从mPackageInfo获取IIntentReceiver,然后通过IPC向AMS发送广播注册请求
#IIntentReceiver是binder，并且具体实现是ReceiverDispatcher的InnerReceiver，ReceiverDispatcher同时保存了BroadcastReceiver和InnerReciver
#可以发现这个实现和Service的bindService很类似，InnerReceiver同样是binder
#广播注册具体由AMS完成，最终汇报InnerReceiver和IntentFilter保存

#发送和接收过程
#发送：AMS查找匹配的receiver。具体是ContextImpl的sendBroadcast方法，该方法请求AMS发送
#AMS中调用broadcastIntentLocked,AMS的源代码从Android5.0开始禁止把广播发送给已经停止的应用
#所以从Android3.1开始，处于停止状态的app无法收到开机广播
#所谓处于停止状态：1.应用安装后还没有运行过 2.应用被手动或者其他应用强停
#broadcastIntentLocked中会根据intent-filter查找匹配的receiver，最终将满足条件的receiver添加到广播队列
#broadcastqueue会iang广播发送给对应的receiver
#broadcasrqueue是通过发送BROADCAST_INTENT_MSG消息，然后broadcastqueue收到消息后会调用processNextBroadcast
#具体发送过程通过deliverToRegisteredReceiverLocked方法发送给特定Receiver
#然后内部又调用了performReceiverLocked方法完成具体发送过程
#然后调用app.thread scheduleRegisterReceiver,然后通过innerReceiver实现广播接受，注意ApplicationThread是binder,所以该方法运行在发起方
#scheduleReceiver通过InnerReceiver实现广播接受，调用InnerReceiver的performReceiver方法
#实际就是调用了实际接收者的发送post异步消息，最终调用receiver的onReceive方法


#ContentProvider:底层同样是binder，ContentProvider的onCreate会优先于Application的onCreate
#app启动的入口实际为ActivityThread#main,在main中创建ActivityThread实例并创建主线程消息队列
#在ActivityThread的attach方法会IPC调用AMS的attachApplication，将ApplicationThread提供给AMS
#ApplicationThread也是binder
#AMS的attachApplication会回调ApplicationThread的bindApplictaion，通过Handler由ActivityThread执行
#然后由ActivityThread执行handleBindApplication，创建Application并加载ContentProvider，其逻辑顺序是先加载ContentProvider
#ContentProvider可以是单例也可以多进程，但一般是单例
#使用ContentResolver访问ContentProvider，ContentResolve获取的实际是ApplicationContentResolver
#当第一次调用contentprovider方法时，如果contentprovider所在进程没有启动，那么会启动其进程
#以query方法举例，会获得一个IContentProvider，具体调用了ActivityThread的acquireProvider
#该方法首先会检查有没有已经获得，如果没有会向AMS查询
#创建过程：创建对应的contextImpl和Instrumentation，创建application，启动contentprovider并调用onCreate，调用application的onCreate
#具体过程还是使用类加载器


#粗略总结就是：客户端(app进程)->AMS(系统进程)->客户端Handler(客户端进程)->客户端方法(客户端进程)






#其实理解AMS最终要应该就是谁提供binder，谁是客户端，谁是service，其中存在大量IPC调用
