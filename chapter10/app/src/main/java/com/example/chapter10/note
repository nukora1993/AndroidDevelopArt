#Android的异步消息机制：Handler、MessageQueue和Looper
#每个线程有自己的Looper，并且存放在ThreadLocal中，这样每个线程都可以很方便的取出自己的Looper
#所谓主线程或者UI线程，实际就是创建ActivityThread的那个线程，其入口为main
#普通线程默认时没有Looper的，主线程默认时有Looper的,如果在某个普通线程中想使用Handler就要为其创建Looper
#检验UI操作时否在主线程中是由ViewRootImpl检查的
#不允许在子线程中进行UI操作，主要是因为UI控件不是线程安全的，如果允许多线程操作UI那么控件处于不可预料状态

#Handler会使用当前线程的Looper来构建内部循环系统，如果没有Looper会报错
#通过Handler的post方法可以将一个Runnable投递到Handler内部的Looper，也可以通过Handler的send发送消息
#send方法会调用MessageQueue,将message放入消息队列，Looper取出并调用Handler的handleMessage
#Looper是在创建Handler所在的线程中执行的
#MessageQueue的实际实现是链表而不是队列，next方法会取出并移除消息，next如果没有消息，那么会阻塞

#为普通线程创建Looper：Looper.prepare方法创建，Looper.loop开始为该线程循环
#getMainLooper：获得主线程的Looper
#Looper.quit:直接退出Looper、Looper.quitSafely:将消息队列所有消息处理完毕才退出
#loop方法是死循环，break的唯一条件是next返回null，而只有调用了Looper.quit,才会调用MessageQueue.quit,next才能返回null

#Handler发消息到MessageQueue，然后Looper取出给对应的Handler处理
#Handler会检查Mesage是否有callback(比如post了一个runnable，那么这个runnable就是callback),如果有则回调该callback，否则调用handler的handleMessage

#note:handler一定是创建在有Looper的线程中的，否则报错
#可以为handler指定looper

#主线程/UI线程的消息循环：
#在main方法中，调用Looper.prepareMainLoop和Looper.loop
#主线程的默认handler是ActivityThread中的H，该Handler处理ApplicationThread发来的
#而ApplicationThread是binder，提供给AMS调用，所以发不发消息由AMS说了算