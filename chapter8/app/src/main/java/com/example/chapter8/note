#一个window对应一个顶级view和一个viewRootImpl，window只是一个概念，顶级view才是window的载体
#对window的访问需要通过windowManager
#windowManager的实现是windowManagerImpl,其中使用WindowManagerGlobal完成操作
#windowManagerGlobal掌管所有window，其中mView存储所有顶级view，mRoot存储所有viewRootsImpl,依次类推
#mDyingViews存储那些正在被删除的Window
#然后通过对应的viewRootImpl通过requestLayout实现异步绘制，最终通过WindowSession完成Window的添加，这是一次IPC过程
#移除window，一般就是移除window的顶级view，同样通过windowManager，ViewRootImpl，一般是异步方式移除
#当顶级view从window移除时，里面的view都会调用onDetachedFromWindow，一般在该方法做资源回收，通过IPC移除window session，移除对应的Root、param和dying
#更新就是更新layoutparam，并调用viewrootimpl完成重绘

#有view的地方就有window
#Activity创建Window（应用window）：
#在activity的attach方法会创建Window对象并设置回调接口，而具体又时通过PolicyManager的makeNewWindow创建的
#而policyManager的实现类时policy类，其makeNewWindow返回的是PhoneWindow,因而Activity的默认window的确是PhoneWindow
#Activity实现了window的callback，所以当window变化时，会回调其中的函数：onAttachedToWindow\onDetachedToWindow\dispatchTouchEvent

#而Activity的setContentView实际调用的是PhoneWindow.setContentView
#大概过程：如果没有decorview，则生成一个，生成过程和系统版本和主题有关，然后将view添加到content中，回调Activity的onContentChanged
#最后在Activity的makeVisible才正式将DecorView添加到Window，完成了window创建

#Dialog的window创建，基本和Activity的window创建相同，而且他的顶级view也是decorview
#但是Dialog的创建时的context必须时Activity的context而不能时Application的context，否则报错
#通过手动设置dialog的window的type为系统级别就可以避免报错

#Toast的创建过程：Toast的window属于系统级别，但是它又显示和取消方法，这个方法是通过IPC方式调用的，并且通过handler具体实现更新
#Toast中有两类IPC过程：1.NotificationManagerService:NMS(非极大值抑制233...) 2.TN:Toast中的回调接口，由NMS调用
#TN是一个binder，tn的方法运行在binder线程池，如果显示或者隐藏，那么需要handler的帮助，所以Toast必须再有looper的线程中弹出
#调用show，会生成tnrecord，然后添加到一个queue，非系统app最多存放50个record（防止DOS），然后NMS会通过callback依次显示
#显示之后通过发送延时消息（取决于设置的延时），然后最终显示（注意tn的binder线程池是客户端的）