#Android中的线程和线程池
#有一些类的底层实现采用了线程或线程池
#AsyncTask就是线程池+Handler，主要方便更新UI
#HandlerThread是具有消息循环线程，这直接使用了线程、IntentService方便自动开启和关闭，其内部使用了ThreadHandler
#IntentService是一种服务，不容易被系统kill

#AsyncTask:在后台开启线程执行，并且将执行进度传递给主线程（使用Handler机制）并更新UI
#doInBaclground在线程池执行
#AsyncTask类必须在主线程加载（Android4.1以上会自动满足该条件）
#AsyncTask对象必须在主线程创建：因为要更新UI，execute方法要在UI线程调用。一个AsyncTask自能执行依次
#在Android1.6之前AsyncTask是穿行的，1.6时采用线程池并行，而Android3.0又采用一个线程串行执行，但是仍然可以通过executeOnExecutor来并行执行
#原理：调用execute->调用executeOnExecutor,其内部采用一个串行线程池
#一个进程中的所有AsyncTask都会在该线程池排队执行
#系统把AsyncTask的Params封装为FutureTask，提交给串行线程池，插入到任务队列，等待执行
#AsyncTask有两个线程池，其中SerialExecutor用于任务排队、THREAD_POOL_EXECUTOR用于实际执行
#AsyncTask包含一个internalHandler，用于切换到UI线程，执行完会使用sHandler发送result，所以sHandler必须在主线程创建
#由于sHandler时static的，访问static时类会被加载，而类加载时会初始化static，所以要求在主线程加载AsyncTask类

#HandlerThread：顾名思义就是可以使用Handler的Thread，实际就是调用Looper.prepare,使得支持Handler

#IntentService:封装了HandlerThread和Handler
#第一次启动IntentService，调用其onCreate，并且创建HandlerThread，和handler，并且使用HandlerThread的looper创建一个handler
#每次启动IntentService其OnStartCommand就会被调用，onStartCommand调用start，start通过handler发送消息，将intent封装在消息中
#消息在handlerThread中被handler处理，调用onHandleIntent，通过intent即可区分具体任务，onHandleIntent执行完毕后，会调用stopSelf(id)来尝试停止服务，这个方法会检查是否还有消息未被处理，如果都处理了，就结束
#因为IntentService内部采用Handler处理消息，所以如果有多个任务，那么任务时顺序执行的（IntentService可以多次start，执行多个任务，但是时顺序的）


#复习ThreadPool
#Executor是一个接口，具体实现类是ThreadPoolExecutor，其提供了参数来配置线程池

